# -*- coding: utf-8 -*-
"""apple .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RcZsDqWu6nLAHPxG4uF9VZUkkowSxk6n
"""

import yfinance as yf

ticker_symbol = 'AAPL'
start_date = '2020-01-01'
end_date = '2025-06-01'

stock_data = yf.download(ticker_symbol, start=start_date, end=end_date)
stock_data = stock_data.reset_index()

print(stock_data.head())

stock_data.to_csv('apple_stock_2020_2025.csv', index=False)

pip install praw

import praw
import pandas as pd
from textblob import TextBlob
from datetime import datetime

reddit = praw.Reddit(
    client_id='rCsEIXZPkqV3WwciMFo3ug',
    client_secret='2xXsGwZWvJAdQAUSusT6Ap52OsLMhg',
    user_agent='apple_sentiment_scraper'
)

def scrape_reddit_sentiment(query, subreddits, start_date, end_date):
    posts = []
    for sub in subreddits:
        print(f"Scraping r/{sub}...")
        try:
            subreddit = reddit.subreddit(sub)
            for submission in subreddit.search(query, sort='new', time_filter='all', limit=1000):
                post_date = datetime.utcfromtimestamp(submission.created_utc).date()
                if start_date <= post_date <= end_date:
                    text = submission.title + " " + submission.selftext
                    sentiment = TextBlob(text).sentiment.polarity
                    posts.append({
                        'date': post_date,
                        'title': submission.title,
                        'text': submission.selftext,
                        'subreddit': sub,
                        'sentiment': sentiment
                    })
        except Exception as e:
            print(f"[ERROR] r/{sub}: {e}")
    return pd.DataFrame(posts)


subreddits = ['stocks', 'investing', 'wallstreetbets', 'Apple', 'technology', 'finance', 'gadgets']
query = 'Apple OR AAPL OR "Apple Inc" OR iPhone OR MacBook OR iPad OR AirPods'
start_date = datetime(2020, 1, 1).date()
end_date = datetime(2025, 6, 1).date()


reddit_df = scrape_reddit_sentiment(query, subreddits, start_date, end_date)
reddit_df.to_csv('apple_reddit_sentiment.csv', index=False)

from google.colab import files

files.download('apple_reddit_sentiment.csv')

pip install vaderSentiment afinn textblob

import re
from nltk.stem import PorterStemmer
import nltk

nltk.download('punkt')

stemmer = PorterStemmer()

reddit_df['combined_text'] = reddit_df['title'].fillna('') + ' ' + reddit_df['text'].fillna('')


reddit_df['cleaned'] = reddit_df['combined_text'].apply(lambda x: re.sub("http\S+", "", x))

reddit_df['cleaned'] = reddit_df['cleaned'].apply(lambda x: re.sub("[^a-zA-Z\s]", "", x))

reddit_df['cleaned'] = reddit_df['cleaned'].apply(lambda x: x.lower())

reddit_df['cleaned'] = reddit_df['cleaned'].apply(lambda x: re.sub("\s+", " ", x).strip())

reddit_df['cleaned'] = reddit_df['cleaned'].apply(
    lambda x: " ".join([stemmer.stem(word) for word in x.split()])
)

print(reddit_df[['date', 'title', 'cleaned']].head())

from textblob import TextBlob

reddit_df['textblob_polarity'] = reddit_df['cleaned'].apply(lambda x: TextBlob(x).sentiment.polarity)

print(reddit_df[['cleaned', 'textblob_polarity']].head())

from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

vader = SentimentIntensityAnalyzer()

reddit_df['vader_compound'] = reddit_df['cleaned'].apply(lambda x: vader.polarity_scores(x)['compound'])

print(reddit_df[['cleaned', 'vader_compound']].head())

import nltk
nltk.download('opinion_lexicon')

from afinn import Afinn

afinn = Afinn()

reddit_df['afinn_score'] = reddit_df['cleaned'].apply(lambda x: afinn.score(x))

print(reddit_df[['cleaned', 'afinn_score']].head())

import nltk
from nltk.corpus import opinion_lexicon

nltk.download('opinion_lexicon')

positive_words = set(opinion_lexicon.positive())
negative_words = set(opinion_lexicon.negative())

def bing(text):
    words = text.split()
    pos = sum(1 for word in words if word in positive_words)
    neg = sum(1 for word in words if word in negative_words)
    return pos - neg

reddit_df['bing_score'] = reddit_df['cleaned'].apply(bing)

print(reddit_df[['cleaned', 'bing_score']].head())

from transformers import AutoTokenizer, AutoModelForSequenceClassification, pipeline

model_name = "ProsusAI/finbert"

tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForSequenceClassification.from_pretrained(model_name)

finbert = pipeline(
    "sentiment-analysis",
    model=model,
    tokenizer=tokenizer,
    truncation=True,
    max_length=512
)

def safe(text, char_limit=2000):
    """
    Truncate text to a safe character length
    """
    return text[:char_limit]

reddit_df['cleaned_trunc'] = reddit_df['cleaned'].fillna('').apply(safe)

def run_finbert(text):
    try:
        result = finbert(text)[0]
        label = result['label']
        score = result['score']

        if label == 'positive':
            return +1 * score
        elif label == 'negative':
            return -1 * score
        else:
            return score
    except Exception as e:
        print(f"Error on text: {text[:30]}...: {e}")
        return 0

reddit_df['finbert_sentiment'] = reddit_df['cleaned_trunc'].apply(run_finbert)

print(reddit_df[['cleaned_trunc', 'finbert_sentiment']].head())

from google.colab import files

reddit_df.to_csv('reddit_df.csv', index=False)

files.download('reddit_df.csv')

files.download('apple_stock_2020_2025.csv')

sample_apple = reddit_df.sample(n=300, random_state=42)

sample_apple.to_csv("sample_apple.csv", index=False)

files.download('sample_apple.csv')

from google.colab import files

import csv
df = pd.read_csv('reddit_df.csv', delimiter=',', quoting=csv.QUOTE_MINIMAL)

df

reddit_df.to_csv('reddit_df.csv')

df.to_csv('reddit_df.csv')

files.download('reddit_df.csv')

df['date'] = pd.to_datetime(df['date'], errors='coerce')


sentiment_cols = ['textblob_polarity', 'vader_compound', 'afinn_score', 'bing_score', 'finbert_sentiment']


df= df.groupby('date')[sentiment_cols].mean().reset_index()

df

i = files.upload()

df1= pd.read_csv('apple_stock_2020_2025 (1).csv')

df1

merged_df

reddit_df

reddit_df.to_csv('apple_reddit_df.csv', index=False, encoding="utf-8-sig")

files.download('apple_reddit_df.csv')

u = files.upload()

df= pd.read_excel('apple combine.xlsx')

df["finbert_edited"]=df["finbert"]
for i in range(1,len(df)):
  today_close= df.loc[i,"close"]
  today_sentiment=df.loc[i,"finbert"]
  yesterday_close=df.loc[i-1,"close"]
  yesterday_sentiment=df.loc[i-1, "finbert"]
  if pd.notnull(today_close) and pd.isnull(today_sentiment):
    if pd.isnull(yesterday_close) and pd.notnull(yesterday_sentiment):
      df1.loc[i,"finbert_edited"]=yesterday_sentiment

merged_df = df.dropna(subset=['close']).reset_index(drop=True)

merged_df = merged_df.fillna(0)

corr= merged_df.corr()

import seaborn as sns
import matplotlib.pyplot as plt

merged_df = merged_df[['date', 'close', 'finbert_edited']]

sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.show()

merged_df.to_csv('apple_final.csv', index=False)

files.download('apple_final.csv')

merged_df

from google.colab import files

uploaded =files.upload()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, GRU, Dense

df= pd.read_csv('apple_final.csv')

df.isnull().sum()

df.info()

df.describe()

plt.figure(figsize=(12, 6))
plt.plot(df['close'], label='Close Price')
plt.title("Stock Closing Price (2020–2025)")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

df['date'] = pd.to_datetime(df['date'])
df.set_index('date', inplace=True)

scaler = MinMaxScaler()
scaled = scaler.fit_transform(df[['close']].values)

plt.figure(figsize=(12, 6))
plt.plot(scaled)
plt.show()
plt.title("after scaling")

plt.subplot(1,2,1)
plt.plot(df['date'], df["close"], label=' Close')
plt.title('before scaling')

plt.ylabel('Price')


plt.subplot(1,2,2)
plt.plot(df['date'], scaled, label='Scaled Close', color='orange')
plt.title('after scaling')

plt.ylabel('Scaled Price')
plt.tight_layout()
plt.show()

plt.plot(df.close)
plt.show()

def create_sequences(data, seq_len):
    X, y = [], []
    for i in range(len(data) - seq_len):
        X.append(data[i:i+seq_len])
        y.append(data[i+seq_len])
    return np.array(X), np.array(y)

seq_len = 60
X, y = create_sequences(scaled, seq_len)

split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]


X_train = X_train.reshape(-1, seq_len, 1)
X_test = X_test.reshape(-1, seq_len, 1)

model = Sequential([
    LSTM(50, return_sequences=False, input_shape=(seq_len, 1)),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test), verbose=1)
y_pred = model.predict(X_test)

plt.figure(figsize=(10, 5))
plt.plot(y_test, label='True Price')
plt.plot(y_pred, label='LSTM Prediction')
plt.title('LSTM Forecast')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

residuals = y_test.flatten() - y_pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error


mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'MSE: {mse:.4f}')
print(f'RMSE: {rmse:.4f}')

from sklearn.metrics import mean_absolute_error, r2_score

mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'MAE: {mae:.4f}')
print(f'R² Score: {r2:.4f}')

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(seq_len, 1)))
model.add(LSTM(32))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

model_fit= model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))
pred = model.predict(X_test)

residuals = y_test.flatten() - pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.plot(y_test, label='Actual')
plt.plot(pred, label='Predicted', linestyle='--')
plt.legend()
plt.title("2-Layer LSTM without Sentiment")
plt.show()

mae = mean_absolute_error(y_test, pred)
r2 = r2_score(y_test, pred)

print(f'MAE: {mae:.4f}')
print(f'R² Score: {r2:.4f}')

rmse = np.sqrt(mean_squared_error(y_test, pred))
print(f'RMSE: {rmse:.4f}')
mse = mean_squared_error(y_test, pred)
print(f'MSE: {mse:.4f}')

"""bi lstm"""

from tensorflow.keras.layers import  Bidirectional
model = Sequential()
model.add(Bidirectional(LSTM(50), input_shape=(seq_len, 1)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
bi_fit = model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))
bi_pred = model.predict(X_test)

residuals = y_test.flatten() - bi_pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.plot(y_test, label='Actual')
plt.plot(bi_pred, label='Bi-LSTM Predicted', linestyle='--')
plt.legend()
plt.title("Bi-LSTM without Sentiment")
plt.show()

rmse = np.sqrt(mean_squared_error(y_test, bi_pred))
print(f'RMSE: {rmse:.4f}')
mse = mean_squared_error(y_test, bi_pred)
print(f'MSE: {mse:.4f}')
r2 = r2_score(y_test, bi_pred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, bi_pred)
print(f'MAE: {mae:.4f}')

"""GRU"""

from tensorflow.keras.layers import GRU

model = Sequential([
    GRU(50, return_sequences=False, input_shape=(seq_len, 1)),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test), verbose=1)
y_pred = model.predict(X_test)



plt.figure(figsize=(10, 5))
plt.plot(y_test, label='True Price')
plt.plot(y_pred, label='GRU Prediction')
plt.title('GRU Forecast')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

residuals = y_test.flatten() - y_pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

from sklearn.metrics import mean_squared_error

mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'MSE: {mse:.4f}')
print(f'RMSE: {rmse:.4f}')

from sklearn.metrics import mean_absolute_error, r2_score

mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'MAE: {mae:.4f}')
print(f'R² Score: {r2:.4f}')

model = Sequential()
model.add(GRU(units=50, return_sequences=True, input_shape=(seq_len, 1)))
model.add(GRU(units=32))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')

gru_1 = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))

pred_gru = model.predict(X_test)

residuals = y_test.flatten() - pred_gru.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.plot(y_test, label='Actual')
plt.plot(pred_gru, label='2-Layer GRU Predicted', linestyle='--')
plt.legend()
plt.title("2-Layer GRU without Sentiment")
plt.show()

rmse= np.sqrt(mean_squared_error(y_test, pred_gru))
print(f'RMSE: {rmse:.4f}')
mse = mean_squared_error(y_test, pred_gru)
print(f'MSE: {mse:.4f}')
r2 = r2_score(y_test, pred_gru)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, pred_gru)
print(f'MAE: {mae:.4f}')

model = Sequential()
model.add(Bidirectional(
    GRU(units=50),
    input_shape=(seq_len, 1)
))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

bi_gru = model.fit(X_train, y_train, epochs=10, batch_size=32, validation_data=(X_test, y_test))

bi_gru = model.predict(X_test)

residuals = y_test.flatten() - bi_gru.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
plt.plot(y_test, label='Actual')
plt.plot(bi_gru, label='Bi-GRU Predicted', linestyle='--')
plt.legend()
plt.title("Bi-directional GRU without Sentiment")
plt.show()

rmse= np.sqrt(mean_squared_error(y_test, bi_gru))
print(f'RMSE: {rmse:.4f}')
mae = mean_absolute_error(y_test, bi_gru)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, bi_gru)
print(f'MSE: {mse:.4f}')
r2 = r2_score(y_test, bi_gru)
print(f'R² Score: {r2:.4f}')

df

df['sentiment_shifted'] = df['finbert_edited'].shift(2)

corr = df.corr()
sns.heatmap(corr, annot=True, cmap="coolwarm")
plt.show()

from google.colab import files
uploaded = files.upload()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, GRU, Dense

df= pd.read_csv('apple_final.csv')

df

df.info()

df.describe()

scaler = MinMaxScaler()
scaled = scaler.fit_transform(df[['close' , "finbert_edited"]])

def create_sequences(data, seq_len):
    X, y = [], []
    for i in range(len(data) - seq_len):
        X.append(data[i:i+seq_len])
        y.append(data[i+seq_len, 0])
    return np.array(X), np.array(y)

seq_len = 60
X, y = create_sequences(scaled, seq_len)

split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]



model = Sequential([
    LSTM(50, input_shape=(seq_len, 2)),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))


ypred = model.predict(X_test)

residuals = y_test.flatten() - ypred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual Price')
plt.plot(ypred, label='Predicted Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid()
plt.show()

r2 = r2_score(y_test, ypred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, ypred)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, ypred)
print(f'MSE: {mse:.4f}')
rmse = np.sqrt(mse)
print(f'RMSE: {rmse:.4f}')

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(seq_len, 2)))
model.add(LSTM(32))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))

ypred = model.predict(X_test)

residuals = y_test.flatten() - ypred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

r2 = r2_score(y_test, ypred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, ypred)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, ypred)
print(f'MSE: {mse:.4f}')
rmse = np.sqrt(mse)
print(f'RMSE: {rmse:.4f}')

plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual Price')
plt.plot(ypred, label='Predicted Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid()
plt.show()

from tensorflow.keras.layers import  Bidirectional
model = Sequential()
model.add(Bidirectional(LSTM(50), input_shape=(seq_len, 2)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
bi_fit = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))
bi_pred = model.predict(X_test)

residuals = y_test.flatten() - bi_pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot ')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

r2 = r2_score(y_test, bi_pred)
print(f'R² Score: {r2:.4f}')
mse = mean_squared_error(y_test, bi_pred)
print(f'MSE: {mse:.4f}')
mae = mean_absolute_error(y_test, bi_pred)
print(f'MAE: {mae:.4f}')
rmse = np.sqrt(mse)
print(f'RMSE: {rmse:.4f}')

plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual Price')
plt.plot(ypred, label='Predicted Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid()
plt.show()

model = Sequential()
model.add(GRU(units=50, return_sequences=False, input_shape=(seq_len, 2)))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test))
ypred = model.predict(X_test)

residuals = y_test.flatten() - ypred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

r2 = r2_score(y_test, ypred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, ypred)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, ypred)
print(f'MSE: {mse:.4f}')
rmse = np.sqrt(mse)
print(f'RMSE: {rmse:.4f}')

"""GRU layer 2 is best among all"""

model = Sequential()
model.add(GRU(units=50, return_sequences=True, input_shape=(seq_len, 2)))
model.add(GRU(units=32))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))

pred = model.predict(X_test)

residuals = y_test.flatten() - pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

r2 = r2_score(y_test, pred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, pred)
print(f'MAE: {mae:.4f}')
mae = mean_absolute_error(y_test, pred)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, pred)
print(f'MSE: {mse:.4f}')

plt.figure(figsize=(12, 6))
plt.plot(y_test, label='Actual Price')
plt.plot(pred, label='Predicted Price')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid()

results = pd.DataFrame({
    'Actual': y_test.flatten(),
    'Predicted': pred.flatten()
})

results

results['Prev_Predicted'] = results['Predicted'].shift(1)
results['Signal'] = results.apply(lambda x:
    'Buy' if x['Predicted'] > x['Prev_Predicted'] * 1.005 else
    'Sell' if x['Predicted'] < x['Prev_Predicted'] * 0.995 else
    'Hold', axis=1)

results.dropna(inplace=True)


print(results[['Actual', 'Predicted', 'Signal']])

import seaborn as sns
import matplotlib.pyplot as plt


custom_palette = {
    'Buy': 'mediumseagreen',
    'Sell': 'red',
    'Hold': 'blue'   }

plt.figure(figsize=(12, 5))
sns.scatterplot(
    x=range(len(results)),
    y=results['Predicted'],
    hue=results['Signal'],
    palette=custom_palette
)
plt.title("Trading Signals Based on GRU layer 2 Forecast")
plt.xlabel("days")
plt.ylabel("Predicted Price")
plt.legend(title='Signal')
plt.show()

import seaborn as sns
plt.figure(figsize=(12, 5))
sns.scatterplot(x=range(len(results)), y=results['Predicted'], hue=results['Signal'], palette='Set1')
plt.title("Trading Signals Based on GRU Forecast")
plt.xlabel("Time")
plt.ylabel("Predicted Price")
plt.show()

model = Sequential()
model.add(Bidirectional(
    GRU(units=50),
    input_shape=(seq_len, 2)
))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mean_squared_error')
model.summary()

model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))

pred = model.predict(X_test)

residuals = y_test.flatten() - pred.flatten()
import matplotlib.pyplot as plt
import pandas as pd


plt.figure(figsize=(12, 5))
plt.plot(residuals, label='Residuals', color='purple')
plt.axhline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Residual Plot')
plt.xlabel('Time')
plt.ylabel('Residual (Actual - Predicted)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()


plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black')
plt.title('Distribution of Residuals')
plt.xlabel('Residual Value')
plt.ylabel('Frequency')
plt.axvline(0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import gaussian_kde

residuals = np.array(residuals)

kde = gaussian_kde(residuals)
x_vals = np.linspace(residuals.min(), residuals.max(), 1000)
kde_vals = kde(x_vals)

plt.figure(figsize=(7, 5))
plt.hist(residuals, bins=30, color='skyblue', edgecolor='black', alpha=0.6, density=True)
plt.plot(x_vals, kde_vals, color='darkblue', linewidth=2, label='Density Curve')
plt.axvline(0, color='red', linestyle='--', label='Zero Error Line')
plt.title('Distribution of Residuals with Density Curve')
plt.xlabel('Residual Value')
plt.ylabel('Density')
plt.legend()
plt.tight_layout()
plt.show()

r2 = r2_score(y_test, pred)
print(f'R² Score: {r2:.4f}')
mae = mean_absolute_error(y_test, pred)
print(f'MAE: {mae:.4f}')
mse = mean_squared_error(y_test, pred)
print(f'MSE: {mse:.4f}')
rmse = np.sqrt(mse)
print(f'RMSE: {rmse:.4f}')















